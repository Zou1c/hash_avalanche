# hash_avalanche
try to explain "Hash avalanche effect"

# ------

哈希雪崩”（Avalanche Effect）是密码学中一个非常重要的概念，特指一个优秀的哈希算法所必须具备的特性。

---

简单来说，哈希雪崩效应指的是，当哈希算法的输入数据发生哪怕一丁点儿的微小改变（例如，只修改一个比特位），其输出的哈希值也会发生天翻地覆、完全不可预测的巨大变化，就像雪崩一样，由一个微小的触发点导致整个山坡的积雪崩塌。

---

# 核心思想
一个理想的哈希算法，其雪崩效应应该达到：**输入数据改变1个比特（bit），输出的哈希值中平均约有50%的比特会发生改变。**
这种“失之毫厘，谬以千里”的特性是哈希函数安全性的基石。

# 举例说明
## 改变一段字符串中的一个字符
我们使用一种非常常见的哈希算法——SHA-256来演示

输入 1: The quick brown fox jumps over the lazy dog
这个句子的SHA-256哈希值是：
d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592

```
现在，我们只做一丁点改动，把句子末尾的 dog 改成 cog。
```

输入 2: The quick brown fox jumps over the lazy cog
这个句子的SHA-256哈希值变成了：
e4c4d8f3bf76b692de791a173e05321150f7a345e4e4093420ebea0b1ddc1e0e

## 结果
对比一下这两个哈希值：
- 输入：仅仅相差一个字母（'d' -> 'c'），在二进制层面可能只是几个比特位的不同。
- 输出：两个32位的十六进制哈希值，你看上去它们之间没有任何关联，完全是两个风马牛不相及的随机字符串。

这就是完美的雪崩效应。你完全无法从输出哈希值的差异，来反推输入数据的差异。

# 特点/特性
哈希雪崩效应是保证哈希函数安全性的几个关键特性的基础：
1. **抗碰撞性 (Collision Resistance)：**
由于微小的输入变化会导致输出的巨大变化，攻击者就很难通过对一个已知的输入进行微调，来找到另一个能产生相同哈希值的输入。如果雪崩效应很弱（比如输入改一点，输出也只改一点），攻击者就可以循序渐进地进行微调，大大增加找到“碰撞”（两个不同输入得到相同输出）的概率。
```
这一点也就是说，防止可能的攻击者硬试一试随便修改一下hash值然后就试出来了（可以还原出原始信息的hash值），计算量上的要求有保证
```
2. **抗原像攻击 (Pre-image Resistance)：**
攻击者无法从一个已知的哈希值反推出原始的输入数据。雪崩效应使得输出和输入之间的关系变得极其混乱和不可预测，就像一个完美的“黑箱”，切断了从输出反推输入的任何线索。
```
关于这一点的说明，可以根据sha256的实机演示说明进行理解（其实应该就是哈希函数的单向性特性）
```
3. **数据完整性校验 (Data Integrity)：**
这是哈希函数最常见的应用之一。比如你下载一个大文件，网站会提供一个哈希值（如MD5或SHA-256）。文件在传输过程中，哪怕只有一个比特因为网络错误而被损坏，你计算出的哈希值将会与官方提供的完全不同。雪崩效应保证了即使是最小的篡改也能被轻易发现。
```
这个就是最常用且可见的应用特性（下载文件的完整性验证）
```

抗碰撞性 ≠ 抗原像攻击（这是一个可能会引发疑问的店，下面的对比会解答这个疑问）

## 与哈希函数单向性有关的详细对比
先说结论：
- 抗碰撞性 ≠ 抗原像攻击
- 一个被证明“不抗碰撞”的算法（如MD5），可能在实践中仍然是“抗原像攻击”的。

### （帮助理解的）假设条件
```
此假设中:
双引号"，包裹起来的，表示其内容为具体的数学符号或公式/方程。  

双引号"，本身不代表任何数学符号。  

双引号"，的使用，主要是为了区分小括号在注释与数学符号间的含义，本文中并没有统一的规范。
```
假设哈希函数是一个神奇的储物柜系统：
1. 输入数据 "m" 就像是你的 物品。
2. 哈希函数 "H" 就像是 储物柜的锁，它根据你的物品自动生成一把独一无二的钥匙。
3. 哈希值 "h=H(m)" 就像是那把 钥匙。
4. *我们假设H是所有人已知的

### 假设条件下的不同场景
#### 1. 抗原像攻击 (Pre-image Resistance)
定义：给定一个哈希值 h，在计算上不可能找到任何一个输入 m，使得 H(m) = h。
- 攻击场景：攻击者手上只有一把钥匙（哈希值 h），他想找到这把钥匙能打开的那个储物柜里存放的原始物品（输入 m）。
- **通俗解释：根据钥匙反推出原始物品（已知h和H，求解m.）。**  

安全要求：这是哈希函数最基本、最核心的单向性要求。如果这个被攻破，哈希函数就毫无安全性可言。  

攻击难度：对于一个 n-bit 的哈希函数，找到一个原像的平均计算复杂度是 2ⁿ。这是一个非常巨大的数字。  

```
储物柜类比：
你捡到了一把钥匙 "h"，你的任务是找到是哪个物品 "m" 生成了这把钥匙。这几乎是不可能的，因为你没有任何线索。（可以认为，你需要用这把钥匙，把所有的2ⁿ的柜子一个一个地试一试能不能打开，才能判断是否找到了物品"m"）
```

---

#### 2. 抗第二原像攻击 (Second Pre-image Resistance)
定义：给定一个输入 m₁，在计算上不可能找到另一个不同的输入 m₂，使得 H(m₁) = H(m₂)。
- 攻击场景：攻击者不仅知道一把钥匙"h"(其中h=H(m₁)), 他还知道这把钥匙对应的原始物品"m₁"。他的目标是找到一个不同的物品"m₂"，也能生成同一把钥匙"h"。
- **通俗解释：为一个已知的物品，伪造一个替代品。(已知m₁, H, h, 求解m₂(其中m₂ != m₁, 并且"h == H(m2)").)**

安全要求：这在防止数字签名伪造时至关重要。攻击者不能用一份恶意合同替换一份合法合同，而让签名依然有效。  

攻击难度：对于一个 n-bit 的哈希函数，找到一个第二原像的平均计算复杂度也是 2ⁿ。  

```
储物柜类比：
我知道物品 m₁（比如一份“无害合同”）可以生成钥匙 h。我的任务是，必须找出另一个不同的物品 m₂（比如一份“恶意合同”），它也能生成这把一模一样的钥匙 h。这同样非常困难。
```

```
！
这或许就是我一直思考的问题，能不能通过已知的所有信息，轻易地产生一个可以生成相同的哈希值的输入
！
```

#### 3. 抗碰撞性 (Collision Resistance)
定义：在计算上不可能找到任何两个不同的输入 m₁ 和 m₂，使得 H(m₁) = H(m₂)。
- 攻击场景：攻击者没有任何限制，他可以自由地创造、修改、尝试任何输入。他的目标是，只要能找出任意一对能生成相同钥匙的物品就行，具体是哪把钥匙、哪个物品他根本不在乎。
- **通俗解释：找出任意一对共享同一把钥匙的不同物品。(已知H, 试找出至少一对m₁和m₂(m₁ != m₂)，使得 H(m₁) = H(m₂))**

攻击难度：由于著名的“生日悖论”(Birthday Paradox)，找到一个碰撞的平均计算复杂度大约是 2ⁿᐟ²。

```
储物柜类比：
我不需要管具体是哪把钥匙。我只要随便找，随便尝试，我的目标是找出任何两个不同的物品 (m₁ 和 m₂)，它们恰好能生成同一把钥匙。
```

```
！
跟我思考的有点像，但目的不完全一样。写此次文章的目的却似乎就是解答通俗解释中的题目，并展示出一个特例求解过程。
！
```

### 核心抽象对比总结
核心区别：攻击者的自由度与难度
| 特性 | 攻击者已知 | 攻击者目标 | 攻击者自由度 | 攻击难度 (n-bit) |
| :--- | :--- | :--- | :--- | :--- |
| **抗原像攻击** | 哈希值 `h` | 找到 `m` 使 `H(m) = h` | 极低（目标已锁定） | `O(2ⁿ)` |
| **抗第二原像攻击** | 输入 `m₁` | 找到 `m₂ ≠ m₁` 使 `H(m₂) = H(m₁)` | 低（目标哈希值已锁定） | `O(2ⁿ)` |
| **抗碰撞性** | （无） | 找到任意 `m₁ ≠ m₂` 使 `H(m₁) = H(m₂)` | 极高（可自由选择输入） | `O(2ⁿᐟ²)` |

所以，这三个特性是哈希函数安全性的三个不同等级，(如果保证了此特性，那么其安全性)从强到弱依次是：  
```
抗碰撞性 > 抗第二原像攻击 > 抗原像攻击
```

### 后续
#### 活生生的例子：MD5（128-bit）
MD5的抗碰撞性：已被完全攻破。早在2004年，中国的王小云院士团队就找到了快速发现MD5碰撞的方法。现在，普通电脑在几秒钟内就能生成一对具有相同MD5值的不同文件。  

MD5的抗原像攻击：至今仍然安全。给你一个MD5哈希值（例如 e10adc3949ba59abbe56e057f20f883e），你几乎不可能通过计算直接反推出它的原像（123456）。你唯一能做的就是“查表”，即使用“彩虹表”等预先计算好的数据库来查询，但这不属于计算攻击。

#### 扩展
##### 1. HMAC
哈希函数在实际应用中的一个核心概念：从“数据完整性”升级到“身份认证”。

- SHA-256 和 MD5 是基础的 哈希算法（如同菜刀和锅）。
- HMAC（Hash-based Message Authentication Code） 是一种使用这些哈希算法来提供消息认证的方法或配方（如同用菜刀和锅做出一道有特定风味的菜——宫保鸡丁）。

##### 2. attestation与authentication
```
简单理解：
- Authentication (认证) 回答的是：“你是谁？” (Who are you?)
- Attestation (证明) 回答的是：“你是什么，以及你的状态是否可信？” (What are you, and can I trust your state?)

它们不是同一个概念，但 Attestation 可以被用作一种极其强大的 Authentication 形式。
```
```
Gemini 2.5 pro结论：  
Authentication 是一个广义的身份验证概念。  

Attestation 是一个特指的技术，用于证明一个计算环境的完整性和真实性。  

Attestation 可以（也经常）被用作实现一种非常高安全级别的 Authentication。 它不再仅仅依赖一个可能被窃取的密码或密钥，而是依赖于不可更改的硬件特性。
```

## 单向性的例子
与操作、异或操作、取模、取模加/取模减等；

与操作和异或操作可以通过真值表看到，只知道一个输出的值，并不能推断出输入是多少（与运算结果为1的情况除外）

注：循环移位并没有信息丢失，只是重排序/混淆；据说可以破坏上述操作的线性关系

# 实验验证（MD5）
## 碰撞性验证
即，找出两个能产生相同hash值的不同文本/字符串/bit

### beginner
1. 找到一个md5在线碰撞网站
https://rivers.chaitin.cn/tools/md5fastcollision

2. 输入原始前缀文本
```
12334
```
然后点击"开始碰撞"

3. 数秒后，生成如下信息
```
碰撞文本 1
31323333340000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000107f3050864c391c7ae40ae17456e0f5b95904502d6f829635163a0e0f18191ad0b5bac4488e1b086bc4c81212e24145d3fa4067889b85bb6b3cbe8240f84287325b28ed741d84030fce6def7fcb23145497b91bf4f80061d517f4c0545a79a24d6f57e22bd78e42c378a08f41e64a880f9dedd9ec694dc5c8929d8f1d869933

碰撞文本 2
31323333340000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000107f3050864c391c7ae40ae17456e0f5b95904d02d6f829635163a0e0f18191ad0b5bac4488e1b086bc4c81212624245d3fa4067889b85bb6b3cbe0240f84287325b28ed741d84030fce6def7fcb23145497b99bf4f80061d517f4c0545a79a24d6f57e22bd78e42c378a08f41664a880f9dedd9ec694dc5c8929d0f1d869933

MD5 哈希
5306f09aa37172d826e747913fd911bf
```

可以通过仔细对比得到，生成的两个文本中是有几个字符是不同的，但大体上非常相似

### challenger
MD5 FastColl，这是一个非常有名的工具，也是密码学攻击史上的一个里程碑。它能非常快速地生成 MD5 碰撞（collision），即找到两个不同的文件，它们却拥有完全相同的 MD5 哈希值。

它的目标是构造碰撞 (Collision Construction)：
找到两个不同的输入 M1 和 M2，使得 MD5(M1) = MD5(M2)。

---

更具体地说，FastColl 实现的是一种更强大的攻击——选择前缀碰撞 (Chosen-Prefix Collision)。这意味着攻击者可以：  
1. 先准备好两个完全不同的“前缀”文件（比如，一份无害的合同 P1 和一份恶意的合同 P2）。
2. 然后，FastColl 会计算出两个不同的、很短的“碰撞块”（或称为“后缀”）S1 和 S2。
3. 将它们分别附加到前缀文件后面，得到两个新文件： File1 = P1 + S1 和 File2 = P2 + S2。
4. 最终 MD5(File1) 将会等于 MD5(File2)。

这极其危险，因为这意味着你可以让某人对一份看起来无害的文件进行数字签名，然后将该签名附加到一份内容完全不同的恶意文件上。

---

MD5的内部结构(Merkle-Damgård)
- 分块处理：MD5将输入数据分成固定大小的块（512位/64字节）。
- 链式计算：它使用一个128位的内部状态（称为“链接变量”；或者说，就是一堆数字；它是一个结构化的、由数字组成的核心组件——四个32位的整数寄存器），这个状态会从一个块的处理传递到下一个块。
    - 状态_1 = 压缩函数(初始状态, 块_1)
    - 状态_2 = 压缩函数(状态_1, 块_2)
    - 状态_3 = 压缩函数(状态_2, 块_3)
    - ...
    - 最终的哈希值就是最后一个块处理完后的内部状态。

这个链式结构是关键。如果攻击者能在链条的任何一个环节让两条不同的路径汇合（可以认为是任何两个状态是相同的），那么之后无论再追加什么相同的数据，这两条路径将永远保持一致（线性可变换为相同的）。

---

差分密码分析 (Differential Cryptanalysis)
——这可以理解为一种**可控的破坏**。

1. 引入一个已知的“差分”：攻击者不是随机尝试，而是精心构造两个输入块，让它们之间存在一个特定的、微小的差异（比如只有一个比特位不同）。

2. 追踪差分的传播：MD5的压缩函数内部有64个步骤，充满了复杂的位运算（与、或、异或、循环移位）。攻击者通过深入分析这些运算，可以预测这个微小的输入差异在每一步之后会如何演变。

3. 寻找“归零”路径：攻击的目标是，找到这样一种特定的输入差异和一系列特定的操作，使得这个差异在经过64步复杂的“搅乱”之后，最终在输出端恰好被完全抵消掉，导致输出的内部状态没有任何差异。

4. 自动化和优化：王小云院士的原始攻击找到了实现这一点的手动数学方法。而后来的研究者（包括Marc Stevens，FastColl的作者）将这个过程高度自动化和优化，使其可以在普通计算机上在几秒钟或几分钟内完成。FastColl 本质上是一个高效的、预先计算好大量“差分路径”的程序，它能根据给定的两个不同前缀产生的内部状态差异，迅速找到能抵消这个差异的碰撞块。

### expert
- 《Fast Collision Attack on MD5》
- 《Chosen-Prefix Collisions for MD5 and  Colliding X.509 Certificates for Different  Identities》


# 思想实验尝试（SHA-256）
Gemini 2.5 pro回答（开头截取）：  
“在我的全部训练数据和知识库中，绝对找不到任何一对内容不同但SHA-256哈希值相同的实例。
原因并非因为我的数据库不够大，而是因为在人类已知的全部信息中，这样的一个实例极有可能根本就不存在。
”

2¹²⁸也许是一个超乎我想象的巨大数字，毕竟想着2的32次方已经能轻松产生碰撞块了（MD5），也许找一个SHA-256的特例并不困难？

Gemini举了一个例子：
```
最大规模的SHA-256计算活动就是比特币挖矿。
当前比特币网络的全网算力：大约是 600 EH/s (Exahashes per second)。(我实际看了一下，大概2025年后在700-900间浮动)
600 EH/s = 600 x 10¹⁸ 次哈希/秒。
即使我们假设比特币网络从诞生以来（约15年）一直保持着这个峰值算力（实际上早期低得多），让我们估算一下总共计算了多少次哈希：
600 x 10¹⁸ (次/秒) × 3600 (秒/时) × 24 (时/天) × 365 (天/年) × 15 (年) ≈ 2.8 x 10²⁹ 次
```
而2¹²⁸大概是10的38次方级别的

尝试与思考仍在进行中…………
